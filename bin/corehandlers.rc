fn nav_tree {
echo -n '<!doctype html><meta charset=utf-8><style>body, nav ul {display: flex;} body {flex-wrap: wrap; margin-right: 10%; margin-left: 10%;} header {flex-basis: 100%; flex-shrink: 0;} article {flex-basis: 60%;} header nav {display: flex;} body > nav {min-width: 16em;} nav ul {flex-direction: column; list-style-type: none;} nav li > ul {padding-left: 0.5em; border-bottom: 1px dashed;} nav li li > ul {padding-left: 0.5em;} h1, h2, h3, h4 {text-align: center; font-weight: 400;} img {width: 150px;} pre {padding-left: 2em;}</style><body><header><nav><a href=http://avsbq.org>HOME</a>-<a href=http://archive.avsbq.org>ARCHIVE</a>-<a href=http://icons.avsbq.org>ICONs</a>-<a href=http://mal.avsbq.org>MAL !</a>-<a href=http://language.avsbq.org>LANG.</a>-<a href=http://links.avsbq.org>LINKs</a>-<a href=http://to-do.avsbq.org>TO-DO</a>-<a href=http://handbook.avsbq.org>HANDBOOK</a><input type="text" id="sB" placeholder="Search"><div id="sR"></div><script src=/s.js></script></nav></header><nav id="side-bar"><div><ul><li><a href=/sitemap>SITEMAP</a></li>'
    ls -F $sitedir/./$req_paths_list >[2]/dev/null \
        | {
            sed $dirfilter'/\/[^_.\/][^\/]*(\.(md)|\/)$/!d; s!^'$sitedir'!!; '$dirclean
            if(! ~ $#synth_paths 0) echo -n $synth_paths | tr ' ' $NEW_LINE
        } | sort -u | awk -F/ '
    function p(x, y, s) { for(i=0; i < x-y; i+=1) printf s }
    BEGIN { lNF=2; }
    {
        d = ""
        if(match($0, "/$"))
            d = "/"
        sub("/$", "") # Strip trailing / for dirs so NF is consistent

        p(NF, lNF, "<li><ul>")
        p(lNF, NF, "</ul></li>")
        lNF = NF

        bname = $NF d
        path = $0 d
        gsub(/[\-_]/, " ", bname)

        # To avoid false matches add trailing / even for plain files to act as delimiter
        pa = path
        gsub(/[^\/]$/, "&/", pa)

        if(index(ENVIRON["req_path"] "/", pa) == 1)
            printf "<li><a href=\"" path "\" class=\"thisPage\">&raquo; "bname"</a></li>"
        else
            printf "<li><a href=\"" path "\">"bname"</a></li>"
    }
    END { p(lNF, 2, "</ul></li>"); printf "</ul></div></nav>" }'
}

fn link_bar {
    if(~ $1 -t) {
        echo -n '<p class="sideBarTitle">'$2'</p>'
        shift; shift
    }
    echo -n '<ul>'
    while(! ~ $#* 0) {
        echo -n '<li><a href="'$2'">- '$1'</a></li>'
        shift; shift
    }
    echo -n '</ul>'
}

fn md_handler { $formatter $1 }

fn tpl_handler { template $* }

fn html_handler {
    # body states: 0 = no <body> found, 2 = after <body>, 1 = after <body></body>, -1 = after </body>
    awk 'gsub(".*<[Bb][Oo][Dd][Yy][^>]*>", "") > 0 {body=2}
        gsub("</ *[Bb][Oo][Dd][Yy][^>]*>.*", "") > 0 {print; body=body-1}
        body==2 {print}
        body==0 {buf=buf "\n" $0}
        END {if(body<=0) {print buf}}' < $1
}

fn setup_handlers {

    if(test -f $local_path.md) {
        local_file=$local_path.md
        handler_body_main=(md_handler $local_file)
    }
    if not if(test -f $local_path.tpl) {
        local_file=$local_path.tpl
        handler_body_main=(tpl_handler $local_file)
    }
    if not if(test -f $local_path.html) {
        local_file=$local_path.html
        handler_body_main=(html_handler $local_file)
    }
    # Global tpl (eg sitemap.tpl), should take precedence over txt handler!
    if not if(test -f tpl^$req_path^.tpl)
        # XXX Should we set $local_file for global .tpls?
        handler_body_main=(tpl_handler tpl^$req_path^.tpl)
    if not if(test -f $local_path.txt) {
        local_file=$local_path.txt
        handler_body_main=(txt_handler $local_file)
    }


    if(! ~ $#handler_body_main 0)
        { } # We are done
    # Canonize explicit .html urls, the web server might handle this first!
    if not if(~ $local_path *.html && test -f $local_path)
        perm_redirect `{ echo -n $req_path|sed 's/.html$//' }
    # Fallback static file handler
    if not if(test -f $local_path)
        static_file $local_path
    if not if(~ $req_path /pub/* && test -f .$req_path)
        static_file .$req_path
    # if not
}

fn run_handlers { for(h in $*) run_handler $$h }
fn run_handler { $*(1) $*(2-) }
