# Werc builtin handlers

fn nav_tree {
    echo -n '<!doctype html><html><head><meta charset="utf-8"><style>body, nav ul { display: flex; } body { flex-wrap: wrap; margin-right: 10%; margin-left: 10%; text-align: justify; } header { flex-basis: 100%; flex-shrink: 0; } article { flex-basis: 60%; padding-left: 1em; } header nav { display: flex; justify-content: space-between; } nav a { text-decoration: none; color: inherit; } body > nav { flex-basis: auto; /* Adjusted to auto to handle width naturally */ padding-right: 1vw; min-width: 16em; /* Fixed width */ } nav ul { flex-direction: column; list-style-type: none; padding-left: 0; margin: 0; /* Reset margin */ } nav li { position: relative; } nav li:last-child { border-bottom: none; /* Remove the border for the last item if desired */ } nav li > ul { padding-left: 0.5em; /* Initial indent for first level of nested lists */ /*margin-top: 0.5em;*/ margin-bottom: 0.5em; border-bottom: 1px dashed #ccc; /* Dashed line for separation */ } nav li li > ul { padding-left: 0.5em; /* Additional indent for deeper levels */ } nav li ul a { padding-left: 0.6em; width: 150px; white-space: nowrap; overflow: hidden; display: block; text-overflow: ellipsis; } h1, h2, h3, h4 { text-align: center; font-weight: 400; line-height: 1.5; margin-bottom: 0.5em; } small { font-size: 30%; } p { margin-bottom: 0; } p.right { text-align: right; } a:link, a:visited { color: #00f; } a:hover { color: red; } a.thisPage { color: red; } a { text-decoration: none; } img { width: 150px; height: auto; transition: transform 0.3s ease, width 0.3s ease; /* Smooth transition for transform and width */ } .br img { background-image: linear-gradient(to right, #7e481c, #4a3728, #7e481c, #4a3728); padding: 0.2em; } pre { padding-left: 2em; } details[open] summary { background-color: #d0d0d0; } details { border: 0.5px dashed black; /* Adds a solid black border */ padding: 5px; /* Adds some padding inside the border */ display: inline-block; /* Ensures the border wraps tightly around the text */ }</style></head><body><header><nav><div><a href="http://avsbq.org">HOME</a> | <a href="http://archive.avsbq.org">ARCHIVE</a> | <a href="http://icons.avsbq.org">ICONs</a> | <a href="http://mal.avsbq.org">MAL !</a> | <a href="http://language.avsbq.org">LANG.</a> | <a href="http://links.avsbq.org">LINKs</a> | <a href="http://to-do.avsbq.org">TO-DO</a> | <a href="http://handbook.avsbq.org">HANDBOOK</a></div><div><a href="http://avsbq.org/.reach">REACH</a> - <a href="http://avsbq.org/.give">GIVE</a> - <a href="/sitemap">SITEMAP</a><br><input type="text" id="searchBar" placeholder="Search currently down"><div id="searchResults"></div><script src="http://archive.avsbq.org/s.js"></script></div></nav></header><nav id="side-bar"><div><ul>'
    ls -F $sitedir/./$req_paths_list >[2]/dev/null \
        | {
            sed $dirfilter'/\/[^_.\/][^\/]*(\.(md)|\/)$/!d; s!^'$sitedir'!!; '$dirclean
            if(! ~ $#synth_paths 0) echo -n $synth_paths | tr ' ' $NEW_LINE
        } | sort -u | awk -F/ '
    function p(x, y, s) { for(i=0; i < x-y; i+=1) printf s }
    BEGIN { lNF=2; }
    {
        d = ""
        if(match($0, "/$"))
            d = "/"
        sub("/$", "") # Strip trailing / for dirs so NF is consistent

        p(NF, lNF, "<li><ul>")
        p(lNF, NF, "</ul></li>")
        lNF = NF

        bname = $NF d
        path = $0 d
        gsub(/[\-_]/, " ", bname)

        # To avoid false matches add trailing / even for plain files to act as delimiter
        pa = path
        gsub(/[^\/]$/, "&/", pa)

        if(index(ENVIRON["req_path"] "/", pa) == 1)
            printf "<li><a href=\"" path "\" class=\"thisPage\"><b>â†ª "bname"</b></a></li>"
        else
            printf "<li><a href=\"" path "\">"bname"</a></li>"
    }
    END { p(lNF, 2, "</ul></li>"); printf "</ul></div></nav>" }'
}

fn link_bar {
    if(~ $1 -t) {
        echo -n '<p class="sideBarTitle">'$2'</p>'
        shift; shift
    }
    echo -n '<ul>'
    while(! ~ $#* 0) {
        echo -n '<li><a href="'$2'">- '$1'</a></li>'
        shift; shift
    }
    echo -n '</ul>'
}

fn md_handler { $formatter $1 }

fn tpl_handler { template $* }

fn html_handler {
    # body states: 0 = no <body> found, 2 = after <body>, 1 = after <body></body>, -1 = after </body>
    awk 'gsub(".*<[Bb][Oo][Dd][Yy][^>]*>", "") > 0 {body=2}
        gsub("</ *[Bb][Oo][Dd][Yy][^>]*>.*", "") > 0 {print; body=body-1}
        body==2 {print}
        body==0 {buf=buf "\n" $0}
        END {if(body<=0) {print buf}}' < $1
}

fn setup_handlers {

    if(test -f $local_path.md) {
        local_file=$local_path.md
        handler_body_main=(md_handler $local_file)
    }
    if not if(test -f $local_path.tpl) {
        local_file=$local_path.tpl
        handler_body_main=(tpl_handler $local_file)
    }
    if not if(test -f $local_path.html) {
        local_file=$local_path.html
        handler_body_main=(html_handler $local_file)
    }
    # Global tpl (eg sitemap.tpl), should take precedence over txt handler!
    if not if(test -f tpl^$req_path^.tpl)
        # XXX Should we set $local_file for global .tpls?
        handler_body_main=(tpl_handler tpl^$req_path^.tpl)
    if not if(test -f $local_path.txt) {
        local_file=$local_path.txt
        handler_body_main=(txt_handler $local_file)
    }


    if(! ~ $#handler_body_main 0)
        { } # We are done
    # Canonize explicit .html urls, the web server might handle this first!
    if not if(~ $local_path *.html && test -f $local_path)
        perm_redirect `{ echo -n $req_path|sed 's/.html$//' }
    # Fallback static file handler
    if not if(test -f $local_path)
        static_file $local_path
    if not if(~ $req_path /pub/* && test -f .$req_path)
        static_file .$req_path
    # if not
}

fn run_handlers { for(h in $*) run_handler $$h }
fn run_handler { $*(1) $*(2-) }
